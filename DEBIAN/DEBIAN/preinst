#!/usr/bin/bash

def_v="osiris2x"

# Leer nombre personalizado, por defecto "osiris2"
read -p "Ingrese el nombre del directorio base (alfanumérico, por defecto '${def_v}'): " x
x=${x:-${def_v}}
if ! [[ "$x" =~ ^[a-zA-Z0-9_-]+$ ]]; then
  echo "Error: El nombre solo puede contener caracteres alfanuméricos, guiones o guiones bajos."
  exit 1
fi

# Variables
base="/var/${x}"
base_bind=$base
x_bind=$x
repo_url="https://github.com/osiris-v2/osiris2.git"
gitinstfn="gitup-release.txt"
gitup_file="${base}/bin/${gitinstfn}"
gitup_remote_inst="bin/${gitinstfn}"
install_log="${base}/inst.json"
temp_repo="${base}/tmp_repo"
temp_gitup="${base}/tmp_gitup"

# Rutas a los archivos de instalación
ok_file="${base}/inst.ok"
error_file="${base}/inst.error"


FORCEUPGRADEMODE="False"
MODE="INIT"

#Archivo temporal de instalación
> /tmp/osiris2_install_vars

#ls $base

    echo "##################################################################"
    echo " INSTALANDO DE BASE:  ${gitinstfn}                                " 
    echo "  COMO: $x_bind                                                   "
    echo "##################################################################"

# Comprobar si existen los archivos de instalaciones anteriores
if [ -f "$ok_file" ] && [ -f "$error_file" ]; then
    # Obtener las fechas de modificación de los archivos
    ok_date=$(stat --format='%Y' "$ok_file")
    error_date=$(stat --format='%Y' "$error_file")
    
    # Comparar las fechas de modificación
    if [ "$ok_date" -gt "$error_date" ]; then
        echo "La última modificación fue exitosa. ${ok_date}"
        cat "$ok_file"
    elif [ "$error_date" -gt "$ok_date" ]; then
        echo "La última modificación fue un error en la instalación."
        cat "$error_file"
    else
        echo "Ambos archivos tienen la misma fecha de modificación.${ok_date}"
        echo "Revisar si hay algún problema con la instalación."
    fi
elif [ -f "$ok_file" ]; then
    echo "La instalación fue exitosa."
    cat "$ok_file"
    if [ -f "$error_file" ]; then
        echo "Errores en la instalaciónes anteriores..."
        cat "$error_file"
    fi
elif [ -f "$error_file" ]; then
    echo "Hubo un error en la instalación anterior."
    cat "$error_file"
else

    echo "##################################################################"
    echo "No se encontró ninguna instalación. Iniciando nueva instalación..."
    echo " SELECCIONE LA OPCION 1   ########################################"
    echo "##################################################################"
    echo " INSTALANDO DE BASE:  ${gitinstfn}                                "
    echo "##################################################################"
    # Aquí se puede llamar al script de instalación que ya tienes
#    ./install_script.sh  # Suponiendo que el script de instalación se llama install_script.sh
fi

# Menú con opciones numéricas
while true; do

   if [[ "$FORCEUPGRADEMODE" == "ForceUpgrade" ]]; then
   
   echo "MODE REINSTALL SELECCIONADO (ForceUpgrade)"
   echo "Selecciones continuar con la instalación (1)"
   echo "Para continuar"
   
   fi

    echo "Seleccione una opción:"
    echo "1) Continuar con la instalación"
    echo "2) Salir de la instalación "
    echo "3) Reiniciar el instalador"
    echo "4) REINSTALAR - UPGRADE"

    # Leer la respuesta del usuario
    read -p "Ingrese el número de la opción deseada: " resp

    # Comprobar la respuesta
    case "$resp" in
        1)
            echo "Continuando con el script..."
            break
            ;;
        2)
            echo "Bye"
            exit 525
            ;;
        3)
            echo "Reiniciando el script..."
            exec "$0" "$@"  # Reejecutar el script
            ;;
        4)
            echo " Modo Upgrade Activado  "
            echo " Pulse ENTER y Seleccione 1 (continuar con la instalación) "
            echo " Para actualizar Versión: ${x} "
            read -p "Continuar con el Mode Force Upgrade  ..."  UPGRADEMODE
            FORCEUPGRADEMODE="ForceUpgrade"
            ;;
        *)
            echo "Opción no válida. Por favor, seleccione una opción entre 1 y 3."
            # No romper el bucle, volver a preguntar
            ;;
    esac
done

echo "CONTINUE ..."



#MODO INSTALL 0


rm -rf $temp_repo

# Crear directorios necesarios
mkdir -p "${base}/bin"
mkdir -p "${temp_repo}"
mkdir -p "${temp_gitup}"


# Descargar ${gitup_remote_inst} del repositorio
echo "Descargando ${gitup_remote_inst} del repositorio..."
git clone --depth 1 --filter=blob:none --sparse "${repo_url}" "${temp_repo}" || {
  echo "Error: No se pudo clonar el repositorio" | tee -a "${install_log}"
  echo '{"status": "error", "message": "No se pudo clonar el repositorio"}' > "${error_file}"
  exit 1
}
cd "${temp_repo}"
git sparse-checkout set --no-cone "/${gitup_remote_inst}" || {
  echo "Error: No se pudo configurar sparse-checkout para ${gitup_remote_inst}" | tee -a "${install_log}"
  echo '{"status": "error", "message": "Error en sparse-checkout para '.${gitup_remote_inst}.'}' > "${error_file}"
  exit 1
}

# Mover gitup.txt a $base/bin/
if [ -f ${gitup_remote_inst} ]; then
  mv "${gitup_remote_inst}" "${temp_gitup}" || {
    echo "Advertencia: No se pudo mover ${gitup_remote_inst} a ${temp_gitup}" | tee -a "${install_log}"
    echo '{"status": "warning", "message": "Error al mover '.${gitup_remote_inst}.'"}' > "${error_file}"
    #exit 1
  }
  echo "${gitinstfn} descargado y copiado a ${temp_gitup}"
else
  echo "Error: ${gitup_remote_inst} no se encuentra en el repositorio" | tee -a "${install_log}"
  echo '{"status": "error", "message": "'.${gitup_remote_inst}.' no encontrado"}' > "${error_file}"
  exit 1
fi

# Limpiar directorio temporal
cd "${base}"
rm -rf "${temp_repo}"


gitup_file="${temp_gitup}/${gitinstfn}"

# Verificar existencia del archivo en $base/bin/
if [ -f "${gitup_file}" ]; then
  echo "${gitinstfn} está en ${gitup_file}. Procediendo con la instalación..." | tee -a "${install_log}"
else
  echo "Error: No se encuentra ${gitup_file} tras descargarlo del repositorio" | tee -a "${install_log}"
  echo '{"status": "error", "message": "'.${gitinstfn}.' no encontrado tras moverlo"}' > "${error_file}"
  exit 1
fi

# Verificar contenido de ${gitinstfn}
echo "Contenido de ${gitinstfn}:"
cat "${gitup_file}"

# Clonación inicial del repositorio para obtener archivos listados
git clone --depth 1 --filter=blob:none --sparse "${repo_url}" "${temp_repo}" || {
  echo "Error: No se pudo clonar el repositorio" | tee -a "${install_log}"
  echo '{"status": "error", "message": "No se pudo clonar el repositorio"}' > "${error_file}"
  exit 1
}
cd "${temp_repo}"

download_fgit() { 
     local file_path=$1
     local install_log=$2
     local error_file=$3
     local MODE=$4
  # Si es directorio, usar git sparse-checkout con --cone
  if [[ "$file_path" == */ ]]; then
    echo "Es un directorio, utilizando sparse-checkout con --cone para ${file_path}"
    git sparse-checkout set --cone "${file_path}" || {
      echo "Error: No se pudo configurar sparse-checkout para ${file_path}" | tee -a "${install_log}"
      echo '{"status": "error", "message": "Error en sparse-checkout"}' > "${error_file}"
      exit 1
    }
  else
    # Si es archivo, hacer sparse-checkout de archivo específico
    echo "Es un archivo, utilizando sparse-checkout para ${file_path}"
    git sparse-checkout set --no-cone "/${file_path}" || {
      echo "Error: No se pudo configurar sparse-checkout para ${file_path}" | tee -a "${install_log}"
      echo '{"status": "error", "message": "Error en sparse-checkout"}' > "${error_file}"
      exit 1
    }
  fi


    if [[ "${MODE}" == "ForceUpgrade" ]]; then
      echo "Sobrescribiendo ${dest}..."
    echo 
    echo " #####$$$$$$######"
      cp "${file_path}" "${dest}" || {
        echo "Error: No se pudo sobrescribir ${file_path} a ${dest}" | tee -a "${install_log}"
        echo '{"status": "error", "message": "Error al mover archivo"}' > "${error_file}"
        # exit 1
      }
      echo "Archivo sobrescrito: ${file_path}" | tee -a "${install_log}"
      continue
    elif [[ "${mode}" == "UPDATE" ]]; then

        mv -f "${file_path}" "${dest}" || {
        echo "Error: No se pudo sobrescribir ${file_path} a ${dest}" | tee -a "${install_log}"
        echo '{"status": "error", "message": "Error al mover archivo"}' > "${error_file}"
        exit 1
      }
       
       
       

    else
      echo "OBSERVAR MODOS"
      echo "No se sobrescribió ${dest}. Continuando con la instalación."
      continue
    fi





}

# Procesar archivos listados en ${gitinstfn}
echo "Procesando archivos listados en ${gitinstfn} ..."

while IFS= read -r line; do
  # Limpiar línea
  line="${line%%*( )}"
  [[ "$line" =~ ^#.*$ || -z "$line" ]] && continue # Saltar comentarios y líneas vacías
  
  # Verificar si la entrada es un archivo o directorio
  file_path="${line}"
  echo "Procesando: ${file_path}"
  dest="${base}/${file_path}"
  if [ -e "${dest}" ]; then
  
    if [[ $FORCEUPGRADEMODE == "ForceUpgrade" ]]; then

    echo "-------------------------------------------------------------"
    echo "¡Advertencia:! El archivo o directorio ${dest} ya existe.    "
    echo "      ESTA USANDO EL MODO REINSTALL                          "
    echo " - MODO FORCEUPGRADE                                         "
    echo " → Se reescribirán los archivos a la última versión estable  "
    echo "-------------------------------------------------------------"
    MODE="ForceUpgrade"  
    sleep 0.1
    else  
    
    echo "---------------------------------------------------------"
    echo "¡Advertencia:! El archivo o directorio ${dest} ya existe."
    echo "      USE MODO REINSTALAR PARA SOBREESCRIBIRLOS          "
    echo " - MODO INSTALL++  → Sólo se instalarán Archivos nuevos  "
    echo "---------------------------------------------------------"
    MODE="UPDATE"
    sleep 0.2
   fi
  

  
   
  fi

  # Verificar si el archivo existe en el repositorio
  echo "Intentando descargar ${file_path} desde el repositorio base..."
 
 
   download_fgit "$file_path"  "$install_log" "$error_file" $MODE


# Verificar si el archivo o directorio fue descargado
if [ -e "${file_path}" ]; then
  dest="${base}/${file_path}"
  dir_path=$(dirname "${dest}")
  mkdir -p "${dir_path}"

  # Verificar si el archivo de destino ya existe
  if [ -e "${dest}" ]; then
    echo "---------------------------------------------------------"
    echo "¡Advertencia:! El archivo o directorio ${dest} ya existe."
    echo "      USE MODO REINSTALAR PARA SOBREESCRIBIRLOS          "
    echo " - MODO INSTALL+   → Sólo se instalarán Archivos nuevos  "
    echo "---------------------------------------------------------"
    sleep 0.3 
    # Preguntar si está en modo actualización 
    answer=$FORCEUPGRADEMODE 
    if [[ "${answer}" == "True" ]]; then
      echo "Sobrescribiendo ${dest}..."
    echo 
    echo " #####$$$$$$######"
    #  mv -f "${file_path}" "${dest}" || {
     #   echo "Error: No se pudo sobrescribir ${file_path} a ${dest}" | tee -a "${install_log}"
    #    echo '{"status": "error", "message": "Error al mover archivo"}' > "${error_file}"
        # exit 1
     # }

      echo "Archivo sobrescrito: ${file_path}" | tee -a "${install_log}"
    else
      echo "No se sobrescribió ${dest}. Continuando con la instalación."
    fi
  else
    # Si el archivo de destino no existe, mover sin preguntar
    mv "${file_path}" "${dest}" || {
      echo "Error: No se pudo mover ${file_path} a ${dest}" | tee -a "${install_log}"
      echo '{"status": "error", "message": "Error al mover archivo"}' > "${error_file}"
      # exit 1
    }
    echo "Archivo descargado: ${file_path}" | tee -a "${install_log}"
  fi
else
  echo "Error: ${file_path} no se encuentra en el repositorio" | tee -a "${install_log}"
  echo '{"status": "error", "message": "'${file_path}' no encontrado en repositorio"}' > "${error_file}"
  echo "\n\n ----->  \n  error remoto !!!  \n\n"
  # sleep 3
  # exit 1
fi
  
done < "${gitup_file}"

# Limpiar directorio temporal
cd "${base}"
rm -rf "${temp_repo}"
rm -rf "${temp_gitup}"

# Gestionar permisos de ejecución
echo "Aplicando permisos de ejecución..."
find "${base}" -type f \( -name "*.sh" -o \( ! -name "*.*" -exec grep -q '^#!' {} \; \) \) -size +0c -exec chmod +x {} \;

# Crear archivo de instalación
if [ $? -eq 0 ]; then
  echo '{"status": "success", "message": "Instalación completada exitosamente"}' > "${ok_file}"
  echo '{"status": "success", "message": "Instalación completada exitosamente"}' | tee "${install_log}"
else
  echo '{"status": "error", "message": "Error durante la instalación"}' > "${error_file}"
  echo '{"status": "error", "message": "Error durante la instalación"}' | tee "${install_log}"
  exit 1
fi

# Imprimir resumen en pantalla
echo "Resumen de la instalación:"
cat "${install_log}"


echo "¿Deseas iniciar osiris ahora? (s/n)"
read -p "Tu elección: " choice

if [[ "$choice" == "s" || "$choice" == "S" ]]; then
    echo "Ejecutando el script..."
    # Aquí llamas a tu script o comando
    echo "EXEC" > /tmp/osiris2_install_vars
    echo "${base_bind}"
    echo "${base_bind}" >> /tmp/osiris2_install_vars
    echo "${x_bind}" >> /tmp/osiris2_install_vars
    echo "Instalando componentes "
else
    echo "Finalizando Tareas...."
    exit 0
fi

