#!/usr/bin/bash

def_v="osiris2x"

# Leer nombre personalizado, por defecto "osiris2"
read -p "Ingrese el nombre del directorio base (alfanumérico, por defecto '${def_v}'): " x
x=${x:-${def_v}}
if ! [[ "$x" =~ ^[a-zA-Z0-9_-]+$ ]]; then
  echo "Error: El nombre solo puede contener caracteres alfanuméricos, guiones o guiones bajos."
  exit 1
fi

# Variables
base="/var/${x}"
repo_url="https://github.com/osiris-v2/osiris2.git"
gitup_file="${base}/bin/gitup.txt"
install_log="${base}/inst.json"
temp_repo="${base}/tmp_repo"
temp_gitup="${base}/tmp_gitup"

# Rutas a los archivos de instalación
ok_file="${base}/inst.ok"
error_file="${base}/inst.error"

ls $base

# Comprobar si existen los archivos de instalaciones anteriores
if [ -f "$ok_file" ] && [ -f "$error_file" ]; then
    # Obtener las fechas de modificación de los archivos
    ok_date=$(stat --format='%Y' "$ok_file")
    error_date=$(stat --format='%Y' "$error_file")
    
    # Comparar las fechas de modificación
    if [ "$ok_date" -gt "$error_date" ]; then
        echo "La última modificación fue exitosa. ${ok_date}"
        cat "$ok_file"
    elif [ "$error_date" -gt "$ok_date" ]; then
        echo "La última modificación fue un error en la instalación."
        cat "$error_file"
    else
        echo "Ambos archivos tienen la misma fecha de modificación.${ok_date}"
        echo "Revisar si hay algún problema con la instalación."
    fi
elif [ -f "$ok_file" ]; then
    echo "La instalación fue exitosa."
    cat "$ok_file"
    if [ -f "$error_file" ]; then
        echo "Errores en la instalaciónes anteriores..."
        cat "$error_file"
    fi
elif [ -f "$error_file" ]; then
    echo "Hubo un error en la instalación anterior."
    cat "$error_file"
else
    echo "No se encontró ninguna instalación. Iniciando nueva instalación..."
    # Aquí se puede llamar al script de instalación que ya tienes
#    ./install_script.sh  # Suponiendo que el script de instalación se llama install_script.sh
fi

# Menú con opciones numéricas
while true; do
    echo "Seleccione una opción:"
    echo "1) Continuar con el script"
    echo "2) Salir del script"
    echo "3) Reiniciar el script"

    # Leer la respuesta del usuario
    read -p "Ingrese el número de la opción deseada: " resp

    # Comprobar la respuesta
    case "$resp" in
        1)
            echo "Continuando con el script..."
            break
            ;;
        2)
            echo "Bye"
            exit 525
            ;;
        3)
            echo "Reiniciando el script..."
            exec "$0" "$@"  # Reejecutar el script
            ;;
        *)
            echo "Opción no válida. Por favor, seleccione una opción entre 1 y 3."
            # No romper el bucle, volver a preguntar
            ;;
    esac
done

echo "CONTINUE ..."



#MODO INSTALL 0


rm -rf $temp_repo

# Crear directorios necesarios
mkdir -p "${base}/bin"
mkdir -p "${temp_repo}"
mkdir -p "${temp_gitup}"


# Descargar bin/gitup.txt del repositorio
echo "Descargando bin/gitup.txt del repositorio..."
git clone --depth 1 --filter=blob:none --sparse "${repo_url}" "${temp_repo}" || {
  echo "Error: No se pudo clonar el repositorio" | tee -a "${install_log}"
  echo '{"status": "error", "message": "No se pudo clonar el repositorio"}' > "${error_file}"
  exit 1
}
cd "${temp_repo}"
git sparse-checkout set --no-cone "/bin/gitup.txt" || {
  echo "Error: No se pudo configurar sparse-checkout para bin/gitup.txt" | tee -a "${install_log}"
  echo '{"status": "error", "message": "Error en sparse-checkout para bin/gitup.txt"}' > "${error_file}"
  exit 1
}

# Mover gitup.txt a $base/bin/
if [ -f "bin/gitup.txt" ]; then
  mv "bin/gitup.txt" "${temp_gitup}" || {
    echo "Advertencia: No se pudo mover bin/gitup.txt a ${temp_gitup}" | tee -a "${install_log}"
    echo '{"status": "warning", "message": "Error al mover gitup.txt"}' > "${error_file}"
    #exit 1
  }
  echo "gitup.txt descargado y copiado a ${temp_gitup}"
else
  echo "Error: bin/gitup.txt no se encuentra en el repositorio" | tee -a "${install_log}"
  echo '{"status": "error", "message": "bin/gitup.txt no encontrado"}' > "${error_file}"
  exit 1
fi

# Limpiar directorio temporal
cd "${base}"
rm -rf "${temp_repo}"


gitup_file="${temp_gitup}/gitup.txt"

# Verificar existencia del archivo en $base/bin/
if [ -f "${gitup_file}" ]; then
  echo "gitup.txt está en ${gitup_file}. Procediendo con la instalación..." | tee -a "${install_log}"
else
  echo "Error: No se encuentra ${gitup_file} tras descargarlo del repositorio" | tee -a "${install_log}"
  echo '{"status": "error", "message": "gitup.txt no encontrado tras moverlo"}' > "${error_file}"
  exit 1
fi

# Verificar contenido de gitup.txt
echo "Contenido de gitup.txt:"
cat "${gitup_file}"

# Clonación inicial del repositorio para obtener archivos listados
git clone --depth 1 --filter=blob:none --sparse "${repo_url}" "${temp_repo}" || {
  echo "Error: No se pudo clonar el repositorio" | tee -a "${install_log}"
  echo '{"status": "error", "message": "No se pudo clonar el repositorio"}' > "${error_file}"
  exit 1
}
cd "${temp_repo}"



# Procesar archivos listados en gitup.txt
echo "Procesando archivos listados en gitup.txt..."

while IFS= read -r line; do
  # Limpiar línea
  line="${line%%*( )}"
  [[ "$line" =~ ^#.*$ || -z "$line" ]] && continue # Saltar comentarios y líneas vacías
  
  # Verificar si la entrada es un archivo o directorio
  file_path="${line}"
  echo "Procesando: ${file_path}"

  # Verificar si el archivo existe en el repositorio
  echo "Intentando descargar ${file_path} desde el repositorio base..."
  
  # Si es directorio, usar git sparse-checkout con --cone
  if [[ "$file_path" == */ ]]; then
    echo "Es un directorio, utilizando sparse-checkout con --cone para ${file_path}"
    git sparse-checkout set --cone "${file_path}" || {
      echo "Error: No se pudo configurar sparse-checkout para ${file_path}" | tee -a "${install_log}"
      echo '{"status": "error", "message": "Error en sparse-checkout"}' > "${error_file}"
      exit 1
    }
  else
    # Si es archivo, hacer sparse-checkout de archivo específico
    echo "Es un archivo, utilizando sparse-checkout para ${file_path}"
    git sparse-checkout set --no-cone "/${file_path}" || {
      echo "Error: No se pudo configurar sparse-checkout para ${file_path}" | tee -a "${install_log}"
      echo '{"status": "error", "message": "Error en sparse-checkout"}' > "${error_file}"
      exit 1
    }
  fi

  
# Verificar si el archivo o directorio fue descargado
if [ -e "${file_path}" ]; then
  dest="${base}/${file_path}"
  dir_path=$(dirname "${dest}")
  mkdir -p "${dir_path}"

  # Verificar si el archivo de destino ya existe
  if [ -e "${dest}" ]; then
    echo "--------------------------------------------------------"
    echo " Advertencia: El archivo o directorio ${dest} ya existe."
    echo "      USE MODO REINSTALAR PARA SOBREESCRIBIRLOS         "
    echo "--------------------------------------------------------"
    sleep 1.5 
    # Preguntar si está en modo actualización 
    read -p "¿Desea sobrescribirlo? (s/n): " answer 
    if [[ "${answer}" =~ ^[Ss]$ ]]; then
      echo "Sobrescribiendo ${dest}..."
      mv -f "${file_path}" "${dest}" || {
        echo "Error: No se pudo sobrescribir ${file_path} a ${dest}" | tee -a "${install_log}"
        echo '{"status": "error", "message": "Error al mover archivo"}' > "${error_file}"
        # exit 1
      }
      echo "Archivo sobrescrito: ${file_path}" | tee -a "${install_log}"
    else
      echo "No se sobrescribió ${dest}. Continuando con la instalación."
    fi
  else
    # Si el archivo de destino no existe, mover sin preguntar
    mv "${file_path}" "${dest}" || {
      echo "Error: No se pudo mover ${file_path} a ${dest}" | tee -a "${install_log}"
      echo '{"status": "error", "message": "Error al mover archivo"}' > "${error_file}"
      # exit 1
    }
    echo "Archivo descargado: ${file_path}" | tee -a "${install_log}"
  fi
else
  echo "Error: ${file_path} no se encuentra en el repositorio" | tee -a "${install_log}"
  echo '{"status": "error", "message": "'${file_path}' no encontrado en repositorio"}' > "${error_file}"
  echo "\n\n ----->  \n  error remoto !!!  \n\n"
  # sleep 3
  # exit 1
fi
  
done < "${gitup_file}"

# Limpiar directorio temporal
cd "${base}"
rm -rf "${temp_repo}"
rm -rf "${temp_gitup}"

# Gestionar permisos de ejecución
echo "Aplicando permisos de ejecución..."
find "${base}" -type f \( -name "*.sh" -o \( ! -name "*.*" -exec grep -q '^#!' {} \; \) \) -size +0c -exec chmod +x {} \;

# Crear archivo de instalación
if [ $? -eq 0 ]; then
  echo '{"status": "success", "message": "Instalación completada exitosamente"}' > "${ok_file}"
  echo '{"status": "success", "message": "Instalación completada exitosamente"}' | tee "${install_log}"
else
  echo '{"status": "error", "message": "Error durante la instalación"}' > "${error_file}"
  echo '{"status": "error", "message": "Error durante la instalación"}' | tee "${install_log}"
  exit 1
fi

# Imprimir resumen en pantalla
echo "Resumen de la instalación:"
cat "${install_log}"

