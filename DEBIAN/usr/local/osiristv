#!/bin/bash

# Interfaz Name: Osiris
# Version: gemini
# Idioma: Espa√±ol


# --- Configuraci√≥n Inicial ---
COMMAND="otvs.sh" # ¬°Aseg√∫rate que esta ruta sea correcta!
LOG_FILE="com/datas/ffmpeg/osiris_launcher.log" # Archivo para logs de lanzamiento de Osiris

#USE VERIFIED
source "/o2iris/venv/bin/activate"
LOG_FILE="/o2iris/datas"
mkdir -p $LOG_FILE
LOG_FILE="/o2iris/datas/osiris_launcher-otvs.log"
>$LOG_FILE
COMMAND="/o2iris/soft/otvs.sh"

declare -A LAUNCHED_PIDS_INFO # otvs_pid => [status_file_path, log_file_path]


# --- Funciones de Utilidad ---

# Funci√≥n para limpiar PIDs muertos del array y actualizar informaci√≥n
check_active_pids() {
    local updated_pids_info=()
    for pid in "${!LAUNCHED_PIDS_INFO[@]}"; do
        # Extraer el path del archivo de estado y log
        IFS=',' read -r status_file log_file <<< "${LAUNCHED_PIDS_INFO["$pid"]}"

        if ps -p "$pid" &>/dev/null; then
            # Si el PID de otvs.sh sigue activo, lo mantenemos en la lista
            updated_pids_info["$pid"]="${LAUNCHED_PIDS_INFO["$pid"]}"
        else
            # Si el PID de otvs.sh ya no est√° activo, reportamos su estado final
            echo "üßπ El proceso otvs.sh con PID $pid ha terminado. "
            if [ -f "$status_file" ]; then
                local final_status=$(cat "$status_file")
                echo "   √öltimo estado de FFMPEG reportado: $final_status"
                # Opcional: Podr√≠as mantener esta entrada por un tiempo si quieres
                # ver los resultados de PIDs terminados, y borrarlos con un comando de limpieza.
                # Por ahora, simplemente se eliminar√° del listado principal.
            fi
            # Los archivos temporales deber√≠an ser limpiados por el trap en otvs.sh.
            # No es necesario limpiar aqu√≠, a menos que otvs.sh no lo haga por alguna raz√≥n.
        fi
    done
    LAUNCHED_PIDS_INFO=("${updated_pids_info[@]}")
}

# Funci√≥n para mostrar la "barra de actualizaci√≥n" de PIDs
display_pid_status() {
    echo ""
    echo "--- Estado de Procesos Osiris (PIDs Activos: ${#LAUNCHED_PIDS_INFO[@]}) ---"
    if [ ${#LAUNCHED_PIDS_INFO[@]} -eq 0 ]; then
        echo "‚ö°Ô∏è No hay procesos de otvs.sh lanzados por esta interfaz."
    else
        for pid in "${!LAUNCHED_PIDS_INFO[@]}"; do
            # Extraer el path del archivo de estado y log
            IFS=',' read -r status_file log_file <<< "${LAUNCHED_PIDS_INFO["$pid"]}"

            local cmd_info=$(ps -p "$pid" -o cmd= --no-headers 2>/dev/null | head -n 1)
            local ffmpeg_status="‚ùî Desconocido (otvs.sh no activo)"

            if ps -p "$pid" &>/dev/null; then
                # Si otvs.sh est√° activo, leemos su archivo de estado de ffmpeg
                if [ -f "$status_file" ]; then
                    ffmpeg_status=$(cat "$status_file")
                    # Limita la longitud del mensaje para no desbordar
                    if [[ ${#ffmpeg_status} -gt 100 ]]; then
                        ffmpeg_status="${ffmpeg_status:0:97}..."
                    fi
                else
                    ffmpeg_status="‚è≥ otvs.sh (PID: $pid) est√° inici√°ndose o el archivo de estado no existe."
                fi
            else
                # Si otvs.sh no est√° activo, intentamos leer el √∫ltimo estado si el archivo a√∫n existe.
                if [ -f "$status_file" ]; then
                    ffmpeg_status="üèÅ Terminado. √öltimo estado: $(cat "$status_file" | head -n 1)"
                else
                    ffmpeg_status="üíÄ Terminado. Estado final desconocido."
                fi
            fi

            if [ -n "$cmd_info" ]; then
                echo "üü¢ PID OTVS: $pid | Comando: ${cmd_info:0:30}... | FFMPEG Estado: $ffmpeg_status"
            else
                echo "‚ö†Ô∏è PID OTVS: $pid | Proceso no encontrado (posiblemente terminando). | FFMPEG Estado: $ffmpeg_status"
            fi
        done
    fi
    echo "---------------------------------------------------"
    echo ""
}

# --- Funciones de Ejecuci√≥n ---

# Ejecuta el comando en una nueva ventana de xterm
run_in_xterm() {
    if command -v xterm &>/dev/null; then
        echo "üöÄ Iniciando '$COMMAND' en una nueva ventana de xterm..."
        # Nohup para desvincular el proceso de la terminal actual
        # xterm -title para poner un t√≠tulo distintivo
        # bash -c '...' para ejecutar el comando
        # exec bash al final de xterm para mantener la ventana de xterm abierta despu√©s de que el comando termine
        # Paso de argumentos: "$@" para pasar cualquier argumento extra de Osiris a otvs.sh
        nohup xterm -title "Osiris: $COMMAND (PID:$$)" -e "bash -c '$COMMAND \"\$@\"; exec bash'" "$@" > "$LOG_FILE" 2>&1 &
        local new_pid=$!
        # Almacenar el PID de otvs.sh y las rutas a sus archivos de estado/log
        LAUNCHED_PIDS_INFO["$new_pid"]="/tmp/otvs_ffmpeg_status_${new_pid}.txt,/tmp/otvs_ffmpeg_log_${new_pid}.log"
        echo "‚ú® PID otvs.sh $new_pid lanzado en xterm. Monitoreando FFMPEG..."
    else
        echo "‚ùå xterm no est√° instalado. Por favor, inst√°lalo para usar esta opci√≥n (ej: sudo apt install xterm)."
    fi
    sleep 1 # Peque√±a pausa para que el usuario vea el mensaje
}

# Ejecuta el comando en el terminal actual (en segundo plano)
run_in_current_terminal() {
    echo "üöÄ Iniciando '$COMMAND' en este terminal (en segundo plano para mantener el men√∫)..."
    # Redirigimos la salida de otvs.sh a nuestro log principal para no llenar el terminal del men√∫
    "$COMMAND" "$@" > "$LOG_FILE" 2>&1 &
    local new_pid=$!
    # Almacenar el PID de otvs.sh y las rutas a sus archivos de estado/log
    LAUNCHED_PIDS_INFO["$new_pid"]="/tmp/otvs_ffmpeg_status_${new_pid}.txt,/tmp/otvs_ffmpeg_log_${new_pid}.log"
    echo "‚ú® PID otvs.sh $new_pid lanzado en este terminal. Monitoreando FFMPEG..."
    echo "üìù La salida principal de otvs.sh se redirige a '$LOG_FILE'."
    sleep 1 # Peque√±a pausa para que el usuario vea el mensaje
}

# --- Funciones de Gesti√≥n de PIDs ---

# Realiza una acci√≥n (kill o info) sobre los PIDs especificados
handle_pid_action() {
    local action="$1" # "kill" o "info"
    local pids_input="$2"

    if [[ -z "$pids_input" ]]; then
        echo "ü§î Por favor, ingresa los PIDs de otvs.sh (separados por comas, ej: '1234,5678'):"
        read -r pids_input
    fi

    # Dividir la cadena de PIDs por comas
    IFS=',' read -ra pids_to_process <<< "$pids_input"

    for pid in "${pids_to_process[@]}"; do
        pid=$(echo "$pid" | xargs) # Limpiar espacios en blanco
        if [[ "$pid" =~ ^[0-9]+$ ]]; then # Validar que es un n√∫mero
            # Extraer el path del archivo de estado y log
            IFS=',' read -r status_file log_file <<< "${LAUNCHED_PIDS_INFO["$pid"]}"

            if ps -p "$pid" &>/dev/null; then
                if [[ "$action" == "kill" ]]; then
                    echo "üíÄ Intentando terminar otvs.sh PID: $pid..."
                    kill "$pid" # Env√≠a SIGTERM, otvs.sh tiene su propio trap para ffmpeg
                    if [ $? -eq 0 ]; then
                        echo "‚úÖ otvs.sh PID $pid ha sido enviado a la muerte. ¬°Adi√≥s! üëã"
                        # Eliminamos de la lista de Osiris inmediatamente
                        unset LAUNCHED_PIDS_INFO["$pid"]
                    else
                        echo "‚ùå No se pudo terminar otvs.sh PID $pid. ¬øPermisos insuficientes o proceso zombie? ü§î"
                    fi
                elif [[ "$action" == "info" ]]; then
                    echo "‚ÑπÔ∏è Informaci√≥n detallada para otvs.sh PID $pid:"
                    ps -fp "$pid"
                    # Mostrar tambi√©n el contenido del archivo de estado de ffmpeg si existe
                    if [ -f "$status_file" ]; then
                        echo "--- √öltimo Estado de FFMPEG (reportado por otvs.sh PID $pid) ---"
                        cat "$status_file"
                    else
                        echo "--- No hay archivo de estado de FFMPEG para PID $pid (¬øno lanzado a√∫n o ya terminado y limpiado?). ---"
                    fi
                    if [ -f "$log_file" ]; then
                        echo "--- √öltimas 20 l√≠neas del Log de FFMPEG (de otvs.sh PID $pid) ---"
                        tail -n 20 "$log_file"
                    else
                        echo "--- No hay archivo de log de FFMPEG para PID $pid. ---"
                    fi
                fi
            else
                echo "‚ö†Ô∏è otvs.sh PID $pid no existe o ya no es un proceso activo. No se puede $action."
                unset LAUNCHED_PIDS_INFO["$pid"] # Si no existe, lo quitamos de nuestra lista
            fi
        else
            echo "üö´ '$pid' no es un PID v√°lido. Debe ser un n√∫mero."
        fi
    done
    sleep 4 # Dar tiempo para leer el output
}

# --- Men√∫ Principal ---

# Muestra las opciones del men√∫
display_menu() {
    clear # Limpia la pantalla para un men√∫ m√°s limpio
    echo "=========================================="
    echo "              üîÆ OSIRIS AI üîÆ             "
    echo "=========================================="
    echo "¬°Bienvenido! Soy tu interfaz con Gemini AI."
    echo "Usa emojis para dinamizar la conversaci√≥n."
    echo "------------------------------------------"
    display_pid_status # Mostrar PIDs antes del men√∫ principal
    echo "--- Opciones Disponibles ---"
    echo "1Ô∏è‚É£  Ejecutar '$COMMAND' en xterm aparte"
    echo "2Ô∏è‚É£  Ejecutar '$COMMAND' en este terminal (fondo)"
    if [ ${#LAUNCHED_PIDS_INFO[@]} -gt 0 ]; then
        echo "3Ô∏è‚É£  Gestionar PIDs activos (Matar o Info) üíÄ‚ÑπÔ∏è"
    else
        echo "3Ô∏è‚É£  Gestionar PIDs (No hay activos para gestionar) üò¥"
    fi
    echo "0Ô∏è‚É£  Salir de Osiris"
    echo "------------------------------------------"
    echo "üí° Consejo: Escribe '--help' para ver los comandos disponibles en cualquier momento."
    echo ""
}

# Muestra la ayuda
display_help() {
    clear
    echo "=========================================="
    echo "              Ayuda de OSIRIS             "
    echo "=========================================="
    echo "Estos son los comandos que puedes usar:"
    echo ""
    echo "‚û°Ô∏è  1: Lanza el comando configurado ('$COMMAND') en una nueva ventana de xterm."
    echo "    La ventana de xterm mostrar√° la salida del script otvs.sh."
    echo "‚û°Ô∏è  2: Lanza el comando configurado ('$COMMAND') en segundo plano en este mismo terminal."
    echo "    La salida de otvs.sh y ffmpeg se redirige a $LOG_FILE."
    echo "‚û°Ô∏è  3: Abre el submen√∫ de gesti√≥n de PIDs. Dentro de este submen√∫:"
    echo "    ‚û°Ô∏è  K <PID> | K <PID1,PID2,...>: Intenta terminar uno o varios PIDs de 'otvs.sh'."
    echo "    ‚û°Ô∏è  I <PID> | I <PID1,PID2,...>: Muestra informaci√≥n detallada del PID de 'otvs.sh',"
    echo "        incluyendo el √∫ltimo estado reportado por FFMPEG y las √∫ltimas l√≠neas de su log."
    echo "    ‚û°Ô∏è  B: Vuelve al men√∫ principal."
    echo "‚û°Ô∏è  0: Sale de la interfaz de Osiris."
    echo "‚û°Ô∏è  --help: Muestra esta pantalla de ayuda."
    echo ""
    echo "Presiona Enter para volver al men√∫..."
    read -r
}

# Maneja la elecci√≥n del usuario
handle_choice() {
    local choice="$1"
    case "$choice" in
        1) run_in_xterm ;;
        2) run_in_current_terminal ;;
        3)
            if [ ${#LAUNCHED_PIDS_INFO[@]} -gt 0 ]; then
                clear
                echo "=== Submen√∫ de Gesti√≥n de PIDs ==="
                display_pid_status # Muestra los PIDs activos tambi√©n aqu√≠
                echo "  K <PID> | K <PIDs,PIDs,...> üíÄ (Matar otvs.sh PID)"
                echo "  I <PID> | I <PIDs,PIDs,...> ‚ÑπÔ∏è (Info de otvs.sh PID y su FFMPEG)"
                echo "  B üîô (Volver al men√∫ principal)"
                echo "-----------------------------------"
                read -p ">>> Ingresa tu acci√≥n: " sub_choice
                local action=$(echo "$sub_choice" | cut -d' ' -f1 | tr '[:lower:]' '[:upper:]')
                local pids=$(echo "$sub_choice" | cut -d' ' -f2-)
                case "$action" in
                    K) handle_pid_action "kill" "$pids" ;;
                    I) handle_pid_action "info" "$pids" ;;
                    B) echo "üîô Volviendo al men√∫ principal." ; sleep 1 ;;
                    *) echo "ü§î Opci√≥n no v√°lida en gesti√≥n de PIDs." ; sleep 1 ;;
                esac
            else
                echo "ü§∑‚Äç‚ôÄÔ∏è No hay PIDs activos lanzados por Osiris para gestionar en este momento."
                sleep 1.5
            fi
            ;;
        0) echo "üëã ¬°Hasta pronto! Saliendo de Osiris. Que tengas un d√≠a genial. üåô" ; exit 0 ;;
        "--help") display_help ;;
        *) echo "üßê Opci√≥n no v√°lida. Por favor, intenta de nuevo o escribe --help." ; sleep 1 ;;
    esac
}

# --- Inicio del Sistema Osiris ---

clear
echo "H E L O S T A R T - Se Ha inciado el SISTEMA OSIRIS a las: $(date '+%Y-%m-%d %H:%M:%S')"
echo ""
echo "üëã ¬°Hola! Soy Osiris, tu interfaz de comunicaci√≥n con Gemini AI. ‚ú® ¬°Qu√© gusto verte por aqu√≠!"
echo ""
echo "Recuerda que si necesitas ayuda o quieres ver los comandos disponibles, puedes escribir '--help'. ¬°Estoy listo para lo que necesites! üöÄ"
sleep 3 # Peque√±a pausa inicial

# --- Bucle Principal del Men√∫ ---
while true; do
    check_active_pids # Siempre verifica PIDs antes de mostrar el men√∫
    display_menu
    read -p "Seleccione una opci√≥n: >>> " choice
    handle_choice "$choice"
done
